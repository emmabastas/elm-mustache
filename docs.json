[{"name":"Mustache","comment":"\n\n# Parse and render\n@docs Ast, render, parse, renderParsed\n\n# Partials\n\nA string can be used as the template in a partial tag.\n\n    import Json.Encode as E\n\n    template : String\n    template = \"\"\"\n    <h2>Names</h2>\n    {{#names}}\n        {{> user}}\n    {{/names}}\n    \"\"\"\n\n    partial : String\n    partial = \"<strong>{{.}}</strong>\"\n\n    render template\n        ( E.object\n            [ (\"names\", E.list E.string [ \"Alice\", \"Bob\" ])\n            , (\"user\", E.string partial)\n            ]\n        )\n    --> [ \"\"\n    --> , \"<h2>Names</h2>\"\n    --> , \"    <strong>Alice</strong>\"\n    --> , \"    <strong>Bob</strong>\"\n    --> , \"\"\n    --> , \"\"\n    --> ]\n    --> |> String.join \"\\n\"\n    --> |> Ok\n\n# Inspecting the parsed contents\n\nIt is not possible to directly inspect the `Ast` type as it contains implementation details. There is however the `Tag` type.\n\n@docs Tag, tags, VariableData, SectionData, InvertedSectionData, PartialData\n\nYou can get data out of the tags with the following functions.\n\n@docs name, Name, sectionContents, invertedSectionContents, contents\n\n# Niche usecases\n@docs htmlEscape, Context, lookup, interpolate, section, invertedSection\n","unions":[{"name":"InvertedSectionData","comment":" ","args":[],"cases":[]},{"name":"PartialData","comment":" ","args":[],"cases":[]},{"name":"SectionData","comment":" ","args":[],"cases":[]},{"name":"Tag","comment":" ","args":[],"cases":[["Variable",["Mustache.VariableData"]],["Section",["Mustache.SectionData"]],["InvertedSection",["Mustache.InvertedSectionData"]],["Partial",["Mustache.PartialData"]]]},{"name":"VariableData","comment":" ","args":[],"cases":[]}],"aliases":[{"name":"Ast","comment":" The AST type.\n","args":[],"type":"List.List Mustache.AstNode"},{"name":"Context","comment":" The *context* is a list of *hashes* (both of these terms are specified in the mustache specification) with the head of the list being the innermost hash.\n","args":[],"type":"List.List Json.Decode.Value"},{"name":"Name","comment":"\n  A mustache tag name represented as a list.\n  The name `foo.bar.baz` is represented by `[\"foo\", \"bar\", \"baz\"]`.\n  The *implicit iterator* `{{.}}` is represented by the empty list `[]`.\n","args":[],"type":"List.List String.String"}],"values":[{"name":"contents","comment":"\n  If a tag is an (inverted) section, get its contents. `Nothing` otherwise.\n","type":"Mustache.Tag -> Maybe.Maybe Mustache.Ast"},{"name":"htmlEscape","comment":" Escape the special HTML characters `&`, `\"`, `<` and `>`. This function is used when rendering values in normal variable tags.\n","type":"String.String -> String.String"},{"name":"interpolate","comment":" Interpolate a JSON value into a string. This function is used when inserting a JSON value into a mustache variable.\n","type":"Maybe.Maybe Json.Decode.Value -> String.String"},{"name":"invertedSection","comment":" Render a mustache inverted section. This is only intended to be used by preparsed templates generated with the `elm-mustache` CLI tool.\n","type":"Mustache.Context -> Mustache.Name -> (Mustache.Context -> String.String) -> String.String"},{"name":"invertedSectionContents","comment":"\n  Get the contents inside an inverted section.\n","type":"Mustache.InvertedSectionData -> Mustache.Ast"},{"name":"lookup","comment":" Given a *context*, lookup a value in it. The lookup rules follows the ones outlined in the mustache specification.\n","type":"Mustache.Context -> Mustache.Name -> Maybe.Maybe Json.Decode.Value"},{"name":"name","comment":"\n  Get the name of a tag.\n\n    \"Hello {{ world }}\\n{{> body.contents }}\"\n    |> parse\n    |> Result.withDefault []\n    |> tags\n    |> List.map name\n    --> [ [\"world\"], [\"body\", \"contents\"] ]\n","type":"Mustache.Tag -> Mustache.Name"},{"name":"parse","comment":" Parse — but don't render — a template. Useful if you want to use the same template many times with different hashes.\n","type":"String.String -> Result.Result (List.List Parser.DeadEnd) Mustache.Ast"},{"name":"render","comment":" This is probably the one function you'll want to use. Expects a mustache template string and a JSON object to use as a hash.\n\n    import Json.Encode as E\n\n    render \"Hello, {{world}}!\" (E.object [(\"world\", E.string \"Pluto\")])  --> Ok \"Hello, Pluto!\"\n","type":"String.String -> Json.Decode.Value -> Result.Result (List.List Parser.DeadEnd) String.String"},{"name":"renderParsed","comment":" Once a template has been parsed with `parse` it can be rendered with this function.\n\n    import Json.Encode as E\n\n    ast : Ast\n    ast = parse \"Hello, {{.}}!\" |> Result.withDefault []\n\n    renderParsed ast (E.string \"Pluto\")  --> \"Hello, Pluto!\"\n\n    renderParsed ast (E.string \"Mercury\")  --> \"Hello, Mercury!\"\n\n","type":"Mustache.Ast -> Json.Decode.Value -> String.String"},{"name":"section","comment":" Render a mustache section. This is only intended to be used by preparsed templates generated with the `elm-mustache` CLI tool.\n","type":"Mustache.Context -> Mustache.Name -> (Mustache.Context -> String.String) -> String.String"},{"name":"sectionContents","comment":"\n  Get the contents inside a section.\n","type":"Mustache.SectionData -> Mustache.Ast"},{"name":"tags","comment":" ","type":"Mustache.Ast -> List.List Mustache.Tag"}],"binops":[]}]